package app.user;

import app.user.dto.LoginDto;
import app.user.exceptions.ValidationError;
import app.utils.requests.RequestError;
import app.user.dto.UserProfileDto;
import app.user.model.User;
import app.user.model.UserLoginData;
import app.user.repository.UserMapper;
import app.user.repository.UserRepository;
import app.user.request.ChangeAccountDataRequest;
import app.user.request.LoginRequest;
import app.user.request.RegisterRequest;
import app.utils.crypto.IdGenerator;
import app.utils.crypto.TokenGenerator;
import app.utils.expiring_token.model.ExpiringToken;
import app.utils.expiring_token.repository.ExpiringTokenRepository;
import com.mongodb.MongoWriteException;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Log4j2
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ExpiringTokenRepository expiringTokenRepository;

    public UserProfileDto getUserByUsername(String username) {
        User user = userRepository.findByUsername(username);

        if (user == null) {
            return null;
        }

        return UserMapper.toUserProfileDto(user);
    }

    public void createUser(RegisterRequest body) {
        String salt = BCrypt.gensalt(10);
        String hash = BCrypt.hashpw(body.getPassword(), salt);

        User user = new User()
                .setName(IdGenerator.getId())
                .setUsername(body.getUsername())
                .setEmail(body.getEmail())
                .setUpdatedAt(new Date())
                .setDisplayName(body.getDisplayName())
                .setLogin(new UserLoginData()
                        .setHashAlgName("BCrypt")
                        .setHash(hash)
                        .setSalt(salt)
                )
                .setMessageHistory(new ArrayList<>())
                .setSearchHistory(new ArrayList<>())
                .setAllergens(new ArrayList<>())
                .setSessions(new ArrayList<>());

        // first insert the created user in the db
        try {
            user = userRepository.save(user);
        } catch (DataIntegrityViolationException e) {
            log.error(e.getMessage());
            throw new RequestError("Validation error");
        }

        // then create the token that the user will use to verify his account
        ExpiringToken token = new ExpiringToken()
                .setValue(TokenGenerator.getToken())
                .setUserId(user.getId())
                .setType("emailConfirm");
        user.getLogin().setChangeToken(token.toEmbedded());

        // then save it to the database
        try {
            expiringTokenRepository.save(token);
        } catch (DataIntegrityViolationException e) {
            log.error(e.getMessage());
            userRepository.delete(user);
            throw new RequestError("Could not create user");
        }

        // here an email should be sent to the user with the token in order to verify their account
    }

    public void verifyToken(String tokenValue) {
        // technically there is no way (yet) to check that the request is sent by the actual user that we're going to verify
        // so if an attacker steals this token they can verify the user's account (doesn't sound risky)
        ExpiringToken token;
        token = expiringTokenRepository.findByValue(tokenValue);

        if (token == null || !token.getType().equals("credentialChange")) {
            throw new RequestError("Invalid token");
        }

        // the token retrieved is for sure the token generated by createRequest
        // try to verify the user
        User user = userRepository.findById(token.getUserId());

        // check if the associated user exists
        if (user == null) {
            expiringTokenRepository.delete(token);
            throw new RequestError("Invalid token");
        }

        // check if the user is already verified and delete their token if so, they don't need to verify their account again
        if (user.getLogin().getEmailStatus().equals("Confirmed")) {
            expiringTokenRepository.delete(token);
            throw new RequestError("User is already verified");
        }

        // verify the user
        user.getLogin().setEmailStatus("Confirmed");
        user.getLogin().setChangeToken(null);

        // save the state
        try {
            userRepository.save(user);
        } catch (Exception e) {
            log.error(e.getMessage());
            throw new RequestError("Could not confirm user");
        }

        // token can be now deleted safely, the user has been verified
        expiringTokenRepository.delete(token);
    }

    public LoginDto login(LoginRequest body) {
        User user = null;

        // get the user by their credentials
        if (body.getUsername() != null) {
            user = userRepository.findByUsername(body.getUsername());
        } else if (body.getEmail() != null) {
            user = userRepository.findByEmail(body.getEmail());
        }

        // check for existence
        if (user == null) {
            log.error("User not found");
            throw new RequestError("Invalid credentials");
        }

        // check that the passwords match
        String hash = BCrypt.hashpw(body.getPassword(), user.getLogin().getSalt());

        if (!user.getLogin().getHash().equals(hash)) {
            log.error("Password did not match");
            throw new RequestError("Invalid credentials");
        }

        // generate a new session for this user
        ExpiringToken token = new ExpiringToken()
                .setValue(TokenGenerator.getToken())
                .setUserId(user.getId())
                .setType("session");

        try {
            expiringTokenRepository.save(token);
        } catch (Exception e) {
            log.error(e);
            throw new RequestError("Could not create session");
        }

        // add the session to the user
        user.addSession(token.toEmbedded());

        try {
            userRepository.save(user);
        } catch (Exception e) {
            log.error(e);
            expiringTokenRepository.delete(token); // delete the token if save failed
            throw new RequestError("Could not create session");
        }

        // return the newly created session to the user
        return UserMapper.toLoginDto(user, token.getValue());
    }

    public List<String> getSearchHistory(String username) {
        User user = userRepository.findByUsername(username);

        return user.getSearchHistory();
    }

    public List<String> getMessageHistory(String username) {
        User user = userRepository.findByUsername(username);

        return user.getMessageHistory();
    }

    public void changeAccountData(String username, ChangeAccountDataRequest body) {
        User user = userRepository.findByUsername(username);

        log.info("{}", user);

        user.setIcon(body.getIcon() != null ? body.getIcon() : user.getIcon())
                .setDisplayName(body.getDisplayName() != null ? body.getDisplayName() : user.getDisplayName())
                .setDescription(body.getDescription() != null ? body.getDescription() : user.getDescription())
                .setAllergens(body.getAllergens() != null ? body.getAllergens() : user.getAllergens());

        log.info("{}", user);

        try {
            userRepository.save(user);
        } catch (MongoWriteException e) {
            log.error(e);
            throw new ValidationError(e);
        }
    }

    public void changeUsername(String username, String newUsername) {
        User user = userRepository.findByUsername(username);

        user.setUsername(newUsername);

        try {
            userRepository.save(user);
        } catch (MongoWriteException e) {
            log.error(e);
            throw new ValidationError(e);
        }
    }

    public void changeEmail(String username, String newEmail) {
        User user = userRepository.findByUsername(username);

        user.setEmail(newEmail);

        try {
            userRepository.save(user);
        } catch (MongoWriteException e) {
            log.error(e);
            throw new ValidationError(e);
        }
    }

    public boolean userExistsByUsername(String username) {
        User user = userRepository.findByUsername(username);

        return (user != null);
    }
}
